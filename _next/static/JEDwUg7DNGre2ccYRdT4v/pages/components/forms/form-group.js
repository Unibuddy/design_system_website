(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{"+wNj":function(e,t,n){"use strict";function r(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}n.d(t,"a",(function(){return r}))},HbGN:function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n("+wNj");function o(e,t){if(null==e)return{};var n,o,a=Object(r.a)(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}},"K+48":function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/components/forms/form-group",function(){return n("k3/H")}])},Km8e:function(e,t,n){"use strict";var r=Object.assign.bind(Object);e.exports=r,e.exports.default=e.exports},ZVZ0:function(e,t,n){"use strict";n.d(t,"a",(function(){return s})),n.d(t,"b",(function(){return f}));var r=n("ERkP"),o=n.n(r);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=o.a.createContext({}),p=function(e){var t=o.a.useContext(c),n=t;return e&&(n="function"===typeof e?e(t):l(l({},t),e)),n},s=function(e){var t=p(e.components);return o.a.createElement(c.Provider,{value:t},e.children)},m="mdxType",b={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},d=o.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,i=e.parentName,c=u(e,["components","mdxType","originalType","parentName"]),s=p(n),m=r,d=s["".concat(i,".").concat(m)]||s[m]||b[m]||a;return n?o.a.createElement(d,l(l({ref:t},c),{},{components:n})):o.a.createElement(d,l({ref:t},c))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"===typeof e||r){var a=n.length,i=new Array(a);i[0]=d;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l[m]="string"===typeof e?e:r,i[1]=l;for(var c=2;c<a;c++)i[c]=n[c];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},cxan:function(e,t,n){"use strict";function r(){return(r=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}n.d(t,"a",(function(){return r}))},"k3/H":function(e,t,n){"use strict";n.r(t),n.d(t,"default",(function(){return f}));var r=n("cxan"),o=n("HbGN"),a=n("ERkP"),i=n.n(a),l=n("ZVZ0"),u=["components"],c=(i.a.createElement,{}),p="wrapper";function s(e){var t=e.components,n=Object(o.a)(e,u);return Object(l.b)(p,Object(r.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(l.b)("h1",null,"FormGroup"),Object(l.b)("p",null,'The purpose of the this component is to automatically "connect" a form input to the Form. We use the formik library which controls the inputs for us and manages the validation. To use it simply wrap a supported input that has a ',Object(l.b)("inlineCode",{parentName:"p"},"name")," prop inside FormGroup and it will be automatically connected to the Form and its value and validation will be controlled automatically for you. Internally, it uses ",Object(l.b)("inlineCode",{parentName:"p"},"FormField"),", so if you want just the layout and styling but want to control the value of the input, use ",Object(l.b)("inlineCode",{parentName:"p"},"FormField")," on its own."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-js"},'import {FormGroup} from "@unibuddy/patron";\n')),Object(l.b)("h2",null,"How to use"),Object(l.b)("p",null,"First, you must have a surrounding Form wrapping your FormGroup(s). Otherwise, your UI will crash. Second, the Form must have that input's name in the ",Object(l.b)("inlineCode",{parentName:"p"},"initialValues"),". Then, add the required ",Object(l.b)("inlineCode",{parentName:"p"},"label")," prop on to FormGroup for accessibility, and a ",Object(l.b)("strong",{parentName:"p"},"single child input as a direct descendent.")," If you have more than one direct child, or that child is not a supported input, it will not work."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-jsx"},'<Form initialValues={{email: ""}}>\n    <FormGroup label="Email">\n        <TextInput name="email" />\n    </FormGroup>\n</Form>\n')),Object(l.b)("p",null,'FormGroup uses a kind of "contract" with its direct child. That direct child must accept ',Object(l.b)("inlineCode",{parentName:"p"},"value")," and ",Object(l.b)("inlineCode",{parentName:"p"},"onChange")," props. Technically, any HTML form element will work out of the box but for the best experience use patron form inputs like TextInput, TextArea, or Select, DateInput, or Autocomplete."),Object(l.b)("h2",null,"Props"),Object(l.b)("p",null,"Since FormGroup composes over ",Object(l.b)("inlineCode",{parentName:"p"},"FormField"),", it passes through all the props it expects like ",Object(l.b)("inlineCode",{parentName:"p"},"label"),", ",Object(l.b)("inlineCode",{parentName:"p"},"helpTop"),", and ",Object(l.b)("inlineCode",{parentName:"p"},"helpBottom"),". The rest which are FormGroup specific are outlined below."),Object(l.b)("h3",null,"Validation and initialValue"),Object(l.b)("p",null,"If you add a required field in to the validationSchema of the Form, and some initial value (so the Form knows it exists), and then never render the that field, the form will have an invisible error that the user can never resolve. Additionally, if you dynamically render some FormGroup in the Form, you also have to update the validationSchema dynamically, and changing initialValues dynamically resets the form. So, the FormGroup has a couple props to solve these problems."),Object(l.b)("p",null,"If you have some element of the form that is being dynamically rendered, you can use the ",Object(l.b)("inlineCode",{parentName:"p"},"validation")," and ",Object(l.b)("inlineCode",{parentName:"p"},"initialValue")," props to dynamically add validation and value initialization for that field when it gets rendered."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-jsx"},'<Form initialValues={{firstName: ""}} validationSchema={{firstName: yup.string().required()}}>\n    <FormGroup label="First Name">\n        <TextInput name="firstName" />\n    </FormGroup>\n    {isBuddy ? (\n        <FormGroup label="Last Name" initialValue="" validation={yup.string().required()}>\n            <TextInput name="lastName" />\n        </FormGroup>\n    ) : null}\n    <SubmitButton>Save</SubmitButton>\n</Form>\n')))}s.isMDXComponent=!0;var m=["components"],b=(i.a.createElement,{}),d="wrapper";function f(e){var t=e.components,n=Object(o.a)(e,m);return Object(l.b)(d,Object(r.a)({},b,n,{components:t,mdxType:"MDXLayout"}),Object(l.b)(s,{mdxType:"Readme"}))}f.isMDXComponent=!0}},[["K+48",0,1]]]);