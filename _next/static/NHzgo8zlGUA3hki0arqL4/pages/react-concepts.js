(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{JTQZ:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/react-concepts",function(){var e=n("UkqC");return{page:e.default||e}}])},UkqC:function(e,t,n){"use strict";n.r(t),n.d(t,"default",function(){return b});var a=n("z3IF"),o=n("2Fjn"),s=(n("mXGw"),n("SAVP")),r=function(e){return function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),Object(s.b)("div",t)}},i=r("ArticleFooter"),c=r("ArticleLink"),l={},p="wrapper";function b(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(s.b)(p,Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(s.b)("h1",null,"React concepts"),Object(s.b)("h2",null,"React documentation"),Object(s.b)("p",null,"Make sure you read through the entire react documentation, it is some of the best technical documentation ever written.\nEspecially the main concepts page is invaluable, for example the pages like ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://reactjs.org/docs/lifting-state-up.html"}),"Lifting State Up")," or ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://reactjs.org/docs/composition-vs-inheritance.html"}),"Composition vs inheritance")," are a must-read.\nAdvanced concepts section also has some great docs that will come in handy when you are debugging some hard to figure out bugs, for example ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://reactjs.org/docs/reconciliation.html"}),"Reconciliation"),"."),Object(s.b)("h2",null,"Smart vs dumb components"),Object(s.b)("p",null,'We used to have a strict separation of smart and dumb components where we would have one top level "container" component per page that held most of business logic and data fetching, and all of this functionality would be passed to various child components through props. There were several issues with this approach, first is that the container components grew too large and were hard to maintain. Avoid adding too much functionality to a single smart component. Now we have a less strict guidelines where you can place a smart container component anywhere in the component hierarchy, and not just on the "page" level.'),Object(s.b)("p",null,'Second problem is usually referred to as "prop drilling" where we need to pass props from one child to the next, nested several levels deep. Generally avoid using "blackbox" components that take a lot of props and pass most of these props down to the next child. If you have a lot of components that just pass the props to their children that usually means these are dumb components and only need some props to customise the css.'),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx"}),"// Main render\n<Component1 prop1={this.someMethod} prop2={state.value1} prop3={state.value2} />\n")),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx"}),"// Component1 render\n<Component2 prop2={props.prop2} prop3={props.prop3} />\n")),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx"}),"// Component2 render\n<div className={props.prop3} />\n")),Object(s.b)("h3",null,"Smart component composition"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"use react context"),Object(s.b)("li",{parentName:"ul"},"render props -> after react hooks are released, prefer hooks"),Object(s.b)("li",{parentName:"ul"},"hocs -> after react hooks are released, prefer hooks"),Object(s.b)("li",{parentName:"ul"},"composition by passing react elements as children and using closure to access functionality of the parent")),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx"}),"// Main render\n<Component1 prop1={this.someMethod}>\n  <Component2 prop3={this.state.value2}>\n    {...}\n  <Component2>\n</Component1>\n")),Object(s.b)("h3",null,"Dumb component composition"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx"}),"function Button({loading, className, children, ...htmlSafeProps}) {\n    return (\n        <button\n            {...htmlSafeProps}\n            className={classNames(s.button, className, {\n                [s.isLoading]: loading,\n            })}\n        >\n            {children}\n        </button>\n    );\n}\n")),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"don't worry about the key prop, it is not passed to child components"),Object(s.b)("li",{parentName:"ul"},"we put ",Object(s.b)("inlineCode",{parentName:"li"},"{...htmlSafeProps}")," at the start so we don't overwrite component local props unexpectedly"),Object(s.b)("li",{parentName:"ul"},"className is extracted so it is not directly applied but instead composed with the component local props. This allows the button to be passed custom css from the component that uses it. It allows for extension, so we could build specific types of Buttons with hardcoded classNames and functionality on top of Button."),Object(s.b)("li",{parentName:"ul"},"htmlSafeProps should only contain props that can be applied to the html button element such as ",Object(s.b)("inlineCode",{parentName:"li"},'data-thing="some value"'),", ",Object(s.b)("inlineCode",{parentName:"li"},"disabled"),", ",Object(s.b)("inlineCode",{parentName:"li"},"style")," etc.")),Object(s.b)("h2",null,"Classes"),Object(s.b)("p",null,"We prefer to avoid constructor, use property initialiser instead."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),'// Don\'t\nclass A extends React.Component {\n    constructor(props) {\n        this.state = {\n            foo: "bar",\n        };\n    }\n}\n')),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),'// Do\nclass A extends React.Component {\n    state = {\n        foo: "bar",\n    };\n}\n')),Object(s.b)("p",null,"You can also reference props since if we omit constructor, super is automatically called with props and this.props is initialised."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"class A extends React.Component {\n    state = {\n        foo: this.props.bar,\n    };\n}\n")),Object(s.b)("p",null,"When you need methods that have ",Object(s.b)("inlineCode",{parentName:"p"},"this")," permanently bound to the class instance (for event listeners, for example) prefer class properties instead of manually binding functions in the constructor or in the render."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"// Don't\nclass A extends React.Component {\n  constructor(props) {\n    this.someMethod = this.someMethod.bind(this)\n  }\n\n  someMethod() { ... }\n}\n")),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"// Do\nclass A extends React.Component {\n  someMethod = () => { ... }\n}\n")),Object(s.b)("h2",null,"Break down components"),Object(s.b)("p",null,'You can often find your components entrenched in "div soup" with a dozen nested layers of divs. And, while overusing divs is a topic on itself for accessibility it also indicates code smell. If your component has complex layout it is often best practice to break this down in to multiple smaller "local" components. If these components are not used elsewhere, and often they don\'t need to be, you don\'t need to create different files for them.'),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx"}),"function MyComponent(props) {\n    return (\n        <div className={s.main}>\n            <div className={s.header}>\n                <div className={s.rightSide}>\n                    <div className={s.avatarContainer}>\n                        <Avatar user={props.user} />\n                    </div>\n                    <Name user={props.user} />\n                </div>\n                <div className={s.leftSide}>\n                    <Button>Chat Now</Button>\n                </div>\n            </div>\n        </div>\n    );\n}\n")),Object(s.b)("p",null,'Looking at this contrived example we can imagine how some components, and especially page components, might grow out of hand. All these divs and classes are making the layout unreadable and non-semantic. You can imagine divs and other html components as "low level" the same way accessing the XMLHttpRequest is low level. It is as low as we can go in the DOM, and in Bob Martins Clean Code book, he notes the switching between levels of abstraction as the main cause of code "un-readability". It is more un-scannable, instead of un-readable, and introduces fatigue in the reader. When the reader is trying to quickly scan the MyComponent render method, they are not interested in classNames and other html attributes, or whether a event handler is onClick or OnKeyDown. At the level of abstraction of the MyComponent code, we are interested in semantic components, and business logic.'),Object(s.b)("p",null,"There are many ways we can go about fixing this, here is one:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx"}),"function MyComponent(props) {\n    return (\n        <Main>\n            <Header rightSlot={<Button>Chat Now</Button>}>\n                <MyAvatar user={props.user} />\n                <Name user={props.user} />\n            </Header>\n            <Body>{props.children}</Body>\n        </Main>\n    );\n}\n")),Object(s.b)("p",null,"How precisely we go about breaking down these components, is up to the author of the component, but what matters is that now we are using semantic elements like ",Object(s.b)("inlineCode",{parentName:"p"},"Main"),", ",Object(s.b)("inlineCode",{parentName:"p"},"Body"),", and ",Object(s.b)("inlineCode",{parentName:"p"},"Header")," that convey some meaning to the reader. Here is one way we could define these smaller components:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx"}),"function Main({children}) {\n    return <div className={s.main}>{children}</div>;\n}\n\nfunction Header({children, rightSlot}) {\n    return (\n        <div className={s.header}>\n            <div className={s.leftSide}>{children}</div>\n            <div className={s.rightSide}>{rightSlot}</div>\n        </div>\n    );\n}\n\nfunction MyAvatar(props) {\n    return (\n        <div className={s.avatarContainer}>\n            <Avatar user={props.user} />\n        </div>\n    );\n}\n\nfunction Body({children}) {\n    return (\n        <div className={s.body}>\n            <div className={s.innerBody}>{children}</div>\n            <div className={s.bodyFooter}>Copyright 2019</div>\n        </div>\n    );\n}\n")),Object(s.b)("h2",null,"Deprecated methods"),Object(s.b)("p",null,"React team has deprecated several methods, and should be avoided from now on. This is documented in ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://reactjs.org/blog/2018/03/29/react-v-16-3.html#component-lifecycle-changes"}),"this blog post"),". These methods still exists in the library and will continue to work until version 17."),Object(s.b)("p",null,"Legacy methods and what you should use instead:"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("inlineCode",{parentName:"li"},"componentWillMount")," -> ",Object(s.b)("inlineCode",{parentName:"li"},"componentDidMount")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("inlineCode",{parentName:"li"},"componentWillUpdate")," -> ",Object(s.b)("inlineCode",{parentName:"li"},"componentDidUpdate")," or ",Object(s.b)("inlineCode",{parentName:"li"},"getSnapshotBeforeUpdate")),Object(s.b)("li",{parentName:"ul"},Object(s.b)("inlineCode",{parentName:"li"},"componentWillReceiveProps")," -> ",Object(s.b)("inlineCode",{parentName:"li"},"componentDidUpdate")," or ",Object(s.b)("inlineCode",{parentName:"li"},"static getDerivedStateFromProps"))),Object(s.b)("h2",null,"Recommended videos"),Object(s.b)("h3",null,"Better composition in react"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.youtube.com/watch?v=hEGg-3pIHlE&t=1191s"}),"Ryan Florence - Compound Components")),Object(s.b)("li",{parentName:"ul"},"A useful video when learning about how to design leaner components that allow for better composition, and therefore, customisability. Useful when working constantly changing requirements, and when developing highly reusable and generic components."),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.youtube.com/watch?v=kp-NOggyz54"}),"Ryan Florence - \u2039Rethinker stop={false}/\u203a")),Object(s.b)("li",{parentName:"ul"},"Ryan, again, talks about how everything is a component."),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.youtube.com/watch?v=BcVAq3YFiuc"}),"Never write another HOC"))),Object(s.b)("h3",null,"React hooks"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.youtube.com/watch?v=dpw9EHDh2bM&t=1s"}),"React Today and Tomorrow and 90% Cleaner React With Hooks")),Object(s.b)("li",{parentName:"ul"},"This one is a long one, at 1 hour and thirty minutes but that is because it is composed from three talks. It is from the react conf 2018 where hooks api was first announced. It is a great introduction and an explainer for hooks.")),Object(s.b)("h3",null,"Future of react"),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.youtube.com/watch?v=nLF0n9SACd4"}),"Dan Abramov: Beyond React 16 | JSConf Iceland 2018")),Object(s.b)("li",{parentName:"ul"},"Dan talks about how Suspense with data fetching (not yet released) will work, and the future of async rendering in react."),Object(s.b)("li",{parentName:"ul"},Object(s.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.youtube.com/watch?v=ByBPyMBTzM0"}),"Concurrent Rendering in React - Andrew Clark and Brian Vaughn - React Conf 2018")),Object(s.b)("li",{parentName:"ul"},"Some more future of react rendering with concurrent rendering")),Object(s.b)(i,{mdxType:"ArticleFooter"},Object(s.b)(c,{href:"/testing",mdxType:"ArticleLink"},"Testing")))}b.isMDXComponent=!0}},[["JTQZ",1,0]]]);