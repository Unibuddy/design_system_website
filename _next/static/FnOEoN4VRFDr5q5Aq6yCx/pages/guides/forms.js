(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{"+wNj":function(e,t,n){"use strict";function r(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}n.d(t,"a",(function(){return r}))},"7AD4":function(e,t,n){"use strict";n.r(t),n.d(t,"default",(function(){return b}));var r=n("cxan"),a=n("HbGN"),o=n("ERkP"),i=n.n(o),s=n("ZVZ0"),l=(i.a.createElement,{}),c="wrapper";function p(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(s.b)(c,Object(r.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(s.b)("h1",null,"Forms"),Object(s.b)("p",null,"The main concept we need to get up to speed on regarding the form handling in react is the controlled vs uncontrolled forms. ",Object(s.b)("strong",{parentName:"p"},"Relevant react documentation ",Object(s.b)("a",{parentName:"strong",href:"https://reactjs.org/docs/forms.html"},"Forms"),".")),Object(s.b)("h2",null,"Controlled vs. Uncontrolled"),Object(s.b)("p",null,"By default, input elements in HTML and in react are uncontrolled, meaning they maintain internal state. React documentation, however, recommends that you build controlled components in most cases, meaning you listen to ",Object(s.b)("inlineCode",{parentName:"p"},"onChange")," event, set the state from that event value, and then pass that state to the input element ",Object(s.b)("inlineCode",{parentName:"p"},"value")," prop. It turns out, this is extremely tedious and too low level when building products, and makes building large forms very slow and bug prone."),Object(s.b)("p",null,"This is the reason there are so many form libraries out there, and most of them focus on two things, maintaining internal control of the state, and validation, while offering some convinient api's as escape hatches. We decided to use ",Object(s.b)("a",{parentName:"p",href:"https://github.com/jaredpalmer/formik"},"Formik")," for managing form state, and ",Object(s.b)("a",{parentName:"p",href:"https://github.com/jquense/yup"},"yup")," for validation."),Object(s.b)("h2",null,"Get Started"),Object(s.b)("p",null,"To start with using our form components you must wrap your inputs with the Form components, add a SubmitButton along the inputs, and finally add an ",Object(s.b)("inlineCode",{parentName:"p"},"onSubmit")," prop to the Form. You can submit the Form by either pressing enter when focused on one of the text inputs, or by pressing the SubmitButton. The onSubmit callback will get called with two arguments - first is the form values, and the second is an object which gives you the imperative methods to call to finish submitting, set an error on the form, or manipulate the internal Form state in some other way."),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-jsx"},'function MyForm() {\n    const onSubmit = (formValues, formActions) => {\n        try {\n            // do something with the form values\n            const {firstName, lastName} = formValues;\n        } catch (error) {\n            // handle error here and set an error on one of the fields for example\n            formActions.setErrors({[error.name]: error.message});\n        } finally {\n            // finfish the submitting process\n            formActions.setSubmitting(false);\n        }\n    };\n\n    return (\n        <Form\n            initialValues={{firstName: "", lastName: ""}}\n            validationSchema={{\n                firstName: yup.string().required(),\n                lastName: yup.string().required(),\n            }}\n            onSubmit={onSubmit}\n        >\n            <FormGroup label="First name">\n                <TextInput name="firstName" required />\n            </FormGroup>\n            <FormGroup label="Last name">\n                <TextInput name="lastName" required />\n            </FormGroup>\n            <SubmitButton>Save</SubmitButton>\n        </Form>\n    );\n}\n')),Object(s.b)("p",null,"In most cases you will want to add the ",Object(s.b)("inlineCode",{parentName:"p"},"initialValues")," and ",Object(s.b)("inlineCode",{parentName:"p"},"validationSchema")," which are both plain object props. If the Form fields don't pass validation step, the onSubmit will not get called. As for the initialValues, besides initializing the form state, it is also useful to let the Form know that a certain field exists in the form. This is useful when showing errors after the first attempt at submitting. If the form doesn't know that the field exists, it will not show the error for that field. The other way the form will know a field exists is when the user interact with the field, but this may not happen."),Object(s.b)("h2",null,"Migrate from a controlled form"),Object(s.b)("p",null,"Our form components are a thin wrapper around Formik. To start wrap all your form inputs in a ",Object(s.b)("inlineCode",{parentName:"p"},"<Form>")," component."),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-jsx"},"<Form>\n    <input value={this.state.value} onChange={this.handleChange} />\n    <button onClick={this.onSubmit}>Submit</button>\n</Form>\n")),Object(s.b)("p",null,"Next we need to wrap the input in a ",Object(s.b)("inlineCode",{parentName:"p"},"<FormGroup>")," component in order to wire up the input with the ",Object(s.b)("inlineCode",{parentName:"p"},"<Form>"),". Next we can remove the value and onChange props as we don't need to control Formik components, the ",Object(s.b)("inlineCode",{parentName:"p"},"<Form>")," holds all the state. Our page only declares what inputs it needs."),Object(s.b)("p",null,"We add ",Object(s.b)("inlineCode",{parentName:"p"},'label="Test"')," prop that internally adds a label element and associates it with the input via a generated or manually provided id. ",Object(s.b)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label"},"Why we do this"),"."),Object(s.b)("p",null,"Finally, we need a ",Object(s.b)("inlineCode",{parentName:"p"},"button")," with a ",Object(s.b)("inlineCode",{parentName:"p"},'type="submit"'),", in order to be able to submit the form by either clicking on it or via enter press."),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-jsx"},'<Form>\n    <FormGroup label="Test">\n        <input name="test" />\n    </FormGroup>\n    <button type="submit">Submit</button>\n</Form>\n')),Object(s.b)("p",null,"In order for formik to differentiate inputs we need to add a name to each of them. See ",Object(s.b)("inlineCode",{parentName:"p"},'name="test"'),"\nFirst, we will replace ",Object(s.b)("inlineCode",{parentName:"p"},"input")," with ",Object(s.b)("inlineCode",{parentName:"p"},"TextInput")," for some nice default styling.\nWe can replace also the ",Object(s.b)("inlineCode",{parentName:"p"},"button")," with a ",Object(s.b)("inlineCode",{parentName:"p"},"<SubmitButton>")," that abstracts away the disabling of the button and loading state."),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-jsx"},'<Form>\n    <FormGroup label="Test">\n        <TextInput name="test" />\n    </FormGroup>\n    <SubmitButton>Submit</SubmitButton>\n</Form>\n')),Object(s.b)("h3",null,"Adding validation"),Object(s.b)("p",null,"Finally to validate the form we add ",Object(s.b)("inlineCode",{parentName:"p"},"validationSchema")," and ",Object(s.b)("inlineCode",{parentName:"p"},"initialValues"),". Initial values is important because that way formik knows which fields exist in the form and therefore are valid/invalid before any onChange is fired."),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-jsx"},'const initialValues = {test: ""};\nconst validationSchema = {\n    test: yup\n        .string()\n        .required()\n        .min(3),\n};\n<Form validationSchema={validationSchema} initialValues={initialValues}>\n    <FormGroup label="Test">\n        <TextInput name="test" />\n    </FormGroup>\n    <SubmitButton>Submit</SubmitButton>\n</Form>;\n')),Object(s.b)("h3",null,"onSubmit"),Object(s.b)("p",null,"In order to get the data from the form we must add a onSubmit callback to the Form component. On form submit Formik ",Object(s.b)("strong",{parentName:"p"},"asynchronously")," validates the form and if all the validation passes calls our onSubmit callback with values as the first argument and internal actions as the second arg."),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-jsx"},'handleSubmit(values, formikActions) {\n try {\n   await mutation(/* ... */);\n } catch (error) {\n     formikActions.setValidation("serverError", error.message);\n } finally {\n     // regardless of error or success, we stop the loading\n     formikActions.setSubmitting(false);\n }\n}\n<Form onSubmit={handleSubmit} initialValues={{serverError: ""}}>\n    {...}\n    <ErrorMessage name="serverError" />\n</Form>\n')),Object(s.b)("p",null,"In order for the serverError error message to show we have to add it to the initial values, otherwise the form will not know that that it exists and formik never shows errors on fields that haven't been interacted with."),Object(s.b)("h2",null,"Testing forms"),Object(s.b)("p",null,"In the previous section we mentioned that the form validation is async, which means you will need to wait for changes in the form in your tests. The testing library of choice is ",Object(s.b)("inlineCode",{parentName:"p"},"@testing-library/react")," because it provides easy async testing utilities like ",Object(s.b)("inlineCode",{parentName:"p"},"waitFor")," and ",Object(s.b)("inlineCode",{parentName:"p"},"findBy*"),". ",Object(s.b)("a",{parentName:"p",href:"https://testing-library.com/docs/api-async"},"RTL async utilities docs"),". ",Object(s.b)("a",{parentName:"p",href:"https://www.notion.so/unibuddy/Front-End-Testing-12447fb9bb3f40e9ae6c5f35dc7a9cd7#eb315a1dfaf6488781a57fe1846d08f9"},"Notion doc for testing forms")),Object(s.b)("h2",null,"Adding a custom form input"),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},"Never add a new form input that cannot be used outside of Form context!")),Object(s.b)("p",null,"In order to add a new input type that interfaces with ",Object(s.b)("inlineCode",{parentName:"p"},"<FormGroup")," and ",Object(s.b)("inlineCode",{parentName:"p"},"<Form>")," it needs to implement a kind of ",Object(s.b)("em",{parentName:"p"},"interface"),".\nThe input needs to be controlled, meaning it has to accept a ",Object(s.b)("strong",{parentName:"p"},"value")," and ",Object(s.b)("strong",{parentName:"p"},"name")," props and emit ",Object(s.b)("strong",{parentName:"p"},"props.onChange")," and ",Object(s.b)("strong",{parentName:"p"},"props.onBlur"),' that emit a "react like" event.\nExample datepicker where ',Object(s.b)("inlineCode",{parentName:"p"},"<DatePicker/>")," is some random library that has weird props like onSelect and inputProps etc...:"),Object(s.b)("pre",null,Object(s.b)("code",{parentName:"pre",className:"language-jsx"},"export default function DatepickerInput(props) {\n    return (\n        <DatePicker\n            selectedDate={props.value}\n            inputProps={{onBlur: props.onBlur}}\n            onSelect={date =>\n                props.onChange({\n                    target: {value: date, name: props.name},\n                })\n            }\n        />\n    );\n}\n")))}p.isMDXComponent=!0;i.a.createElement;var u={},m="wrapper";function b(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(s.b)(m,Object(r.a)({},u,n,{components:t,mdxType:"MDXLayout"}),Object(s.b)(p,{mdxType:"Readme"}))}b.isMDXComponent=!0},HbGN:function(e,t,n){"use strict";n.d(t,"a",(function(){return a}));var r=n("+wNj");function a(e,t){if(null==e)return{};var n,a,o=Object(r.a)(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}},Km8e:function(e,t,n){"use strict";var r=Object.assign.bind(Object);e.exports=r,e.exports.default=e.exports},ZVZ0:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return h}));var r=n("ERkP"),a=n.n(r);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=a.a.createContext({}),p=function(e){var t=a.a.useContext(c),n=t;return e&&(n="function"===typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=p(e.components);return a.a.createElement(c.Provider,{value:t},e.children)},m="mdxType",b={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},d=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),m=r,d=u["".concat(i,".").concat(m)]||u[m]||b[m]||o;return n?a.a.createElement(d,s(s({ref:t},c),{},{components:n})):a.a.createElement(d,s({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"===typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"===typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},cxan:function(e,t,n){"use strict";function r(){return(r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}n.d(t,"a",(function(){return r}))},kNQ3:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/guides/forms",function(){return n("7AD4")}])}},[["kNQ3",0,1]]]);