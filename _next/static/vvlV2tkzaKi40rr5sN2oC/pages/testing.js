(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{CpCh:function(e,t,n){"use strict";n.r(t),n.d(t,"default",function(){return p});var o=n("z3IF"),r=n("2Fjn"),a=(n("mXGw"),n("SAVP")),i=function(e){return function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),Object(a.b)("div",t)}},s=i("ArticleFooter"),l=i("ArticleLink"),c={},b="wrapper";function p(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(a.b)(b,Object(o.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h1",null,"Testing"),Object(a.b)("h2",null,"Overview"),Object(a.b)("p",null,"Testing the front end components is currently done in two general ways, shallow and mount tests both using ",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"https://airbnb.io/enzyme/"}),"enzyme")," provided functions (react-native only supports shallow), and a newer way using ",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"https://testing-library.com/react"}),"react-testing-library")," from Kent C. Dodds, and ",Object(a.b)("strong",{parentName:"p"},"react-testing-library is generally preferred"),"."),Object(a.b)("p",null,'The react-testing-library encourages testing closer to what the user does in the browser by providing easy selectors from box and disables accessing the component internal state and props. In fact this library "pretends" to not know react even exists and acts as an extension of dom-testing-library. Besides a plethora of useful selectors another way it helps with integration tests is by providing "wait" utilities.'),Object(a.b)("p",null,"We are also using the ",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"https://github.com/gnapse/jest-dom"}),"jest dom library")," for better dom assertions."),Object(a.b)("h2",null,"Problem"),Object(a.b)("p",null,"When writing integration tests the biggest issue usually is async nature of the browser interaction and React rendering cycles.\nFor example we will usually have the following test scenario:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'import {render, fireEvent} from "react-testing-library";\n\ntest("should change after click", () => {\n    const {getByTestId} = render(<MyComponent />);\n\n    fireEvent.click(getByTestId("some-button"));\n\n    expect(getByTestId("some-dynamic-element")).toBeInTheDocument();\n});\n')),Object(a.b)("p",null,"This will often fail, because the rendering will be async for any number of reasons. When using forms, for example, the validation is async, so any errors and form submission will not be executed immediately. Or if the button triggers a query, and only after it is resolved, the dynamic element will be available."),Object(a.b)("p",null,"The way to solve this is to use ",Object(a.b)("inlineCode",{parentName:"p"},"wait")," or ",Object(a.b)("inlineCode",{parentName:"p"},"waitForElement")," from ",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"https://testing-library.com/docs/api-async"}),"async utilities")),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-diff"}),'- import {render, fireEvent} from "react-testing-library";\n+ import {render, fireEvent, wait, waitForElement} from "react-testing-library";\n\n- test("should change after click", () => {\n+ test("should change after click", async () => {\n    const {getByTestId} = render(<MyComponent/>);\n\n    fireEvent.click(getByTestId("some-button"))\n\n-   expect(getByTestId("some-dynamic-element")).toBeInTheDocument();\n+   await wait(() => expect(getByTestId("some-dynamic-element")).toBeInTheDocument());\n    // or...\n+   await waitForElement(() => getByTestId("some-dynamic-element"));\n});\n')),Object(a.b)("h2",null,"Prefer mount over shallow"),Object(a.b)("p",null,'Going forward we should prioritise integration tests for higher level components, and tests that are closer to what the browser renders for the low level ones. Keep in mind that enzyme\'s mount function uses JSDOM to render the react tree in to a "virtual" browser, and one of the downsides of this is that the elements, for example, have no dimensions. In case you want to test element size, scroll position, visibility etc. this is not possible with JSDOM.'),Object(a.b)("p",null,"In many cases this will be difficult and/or time consuming since this is a relatively new practice and for high level components it requires a lot of boilerplate. We should aim to create reusable tools, utilities, and boilerplate for testing wherever possible."),Object(a.b)("p",null,"Using mount over shallow has one major benefit, and that is that we are not relying on enzyme internals as much as we do when we are using shallow. Since shallow implements its own renderer the enzyme library has to manually add support for every new React feature, and this has been historically very slow to happen."),Object(a.b)("h2",null,"Integration mocking"),Object(a.b)("p",null,"In order to mount or render a high level component you might need some or all of the following setup:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"MockedProvider from ",Object(a.b)("inlineCode",{parentName:"li"},"react-apollo/test-utils")," in order to mock queries and mutations"),Object(a.b)("li",{parentName:"ul"},"Provider wrapper from ",Object(a.b)("inlineCode",{parentName:"li"},"rect-redux")," with a new mocked store"),Object(a.b)("li",{parentName:"ul"},"MemoryRouter wrapper from ",Object(a.b)("inlineCode",{parentName:"li"},"rect-router")," if the component is using a withRouter hoc or any of the ",Object(a.b)("inlineCode",{parentName:"li"},"react router-dom")," components"),Object(a.b)("li",{parentName:"ul"},"mocking imported modules using ",Object(a.b)("inlineCode",{parentName:"li"},"jest.mock()"))),Object(a.b)("h3",null,"Apollo mocking"),Object(a.b)("p",null,Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"https://www.apollographql.com/docs/react/recipes/testing.html"}),"Apollo react testing documentation"),"\nWe should aim to reuse university, user and other common query and mutation mock files, and aggregate in one place."),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'const mocks = [\n    {\n        request: {\n            query: someMutation,\n            variables: {\n                thingId: "1",\n                newValue: "hello",\n            },\n        },\n        result: {\n            loading: false,\n            data: {\n                someMutation: { thingId: "1", newValue: "hello" },\n            },\n        },\n    },\n];\nconst wrapper = mount(<MockedProvider mocks={mocks} addTypename={false}>\n  <SomeComponmentThatUsesApollo/>\n</MockedProvider>\n')),Object(a.b)("h2",null,"Writing tests as documentation in jest"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"use ",Object(a.b)("inlineCode",{parentName:"li"},"describe")," blocks to describe the condition"),Object(a.b)("li",{parentName:"ul"},"use ",Object(a.b)("inlineCode",{parentName:"li"},"it")," blocks to test each of the expected results under that condition")),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),'describe("when condition x", () => {\n  it("should render x", () => {...});\n  it("should call prop x with data", () => {...});\n  it("should NOT render y", () => {...});\n});\ndescribe("when condition y", () => {\n  it("should render y", () => {...});\n  it("should NOT call prop x", () => {...});\n});\n')),Object(a.b)("h2",null,"Shallow testing"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"for render props pattern we are using ",Object(a.b)("inlineCode",{parentName:"li"},"@commercetools/enzyme-extensions")," npm package which allows us to do following:")),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'test("Should be enabled if no rows", () => {\n    const wrapper = shallow(<TopLevelComponent />);\n    const newWrapper = wrapper.find(ComponentThatUsesRenderProps).renderProp("children", {}); // or "render" if using a prop for example\n    const button = newWrapper.find(Button).at(0);\n    expect(addButton.props().disabled).toBe(false);\n});\n')),Object(a.b)(s,{mdxType:"ArticleFooter"},Object(a.b)(l,{href:"/experimental",mdxType:"ArticleLink"},"Experimental"),Object(a.b)(l,{align:"right",href:"/react-concepts",mdxType:"ArticleLink"},"React concepts")))}p.isMDXComponent=!0},we64:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/testing",function(){var e=n("CpCh");return{page:e.default||e}}])}},[["we64",1,0]]]);